"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const R = require("ramda");
const mongoose = require("mongoose");
const pluralize = require("pluralize");
const parse_query_params_1 = require("../../steps/pre-query/parse-query-params");
const misc_1 = require("../../util/misc");
const objectValueEntries_1 = require("../../util/objectValueEntries");
const schema_1 = require("./utils/schema");
const subtyping_1 = require("./utils/subtyping");
const doc_to_resource_1 = require("./utils/doc-to-resource");
const naming_conventions_1 = require("../../util/naming-conventions");
const util = require("./lib");
const Errors = require("../../util/errors");
const Data_1 = require("../../types/Generic/Data");
const Field_1 = require("../../types/Documentation/Field");
const FieldType_1 = require("../../types/Documentation/FieldType");
const RelationshipType_1 = require("../../types/Documentation/RelationshipType");
const CreateQuery_1 = require("../../types/Query/CreateQuery");
const FindQuery_1 = require("../../types/Query/FindQuery");
const DeleteQuery_1 = require("../../types/Query/DeleteQuery");
const UpdateQuery_1 = require("../../types/Query/UpdateQuery");
const AddToRelationshipQuery_1 = require("../../types/Query/AddToRelationshipQuery");
const RemoveFromRelationshipQuery_1 = require("../../types/Query/RemoveFromRelationshipQuery");
class MongooseAdapter {
    constructor(models = mongoose.models, toTypeName = naming_conventions_1.getTypeName, idGenerator) {
        this.models = models;
        this.toTypeName = toTypeName;
        this.idGenerator = idGenerator;
        this.typeNamesToModelNames = {};
        this.modelNamesToTypeNames = {};
        for (const modelName of Object.keys(models)) {
            const typeName = toTypeName(modelName);
            this.typeNamesToModelNames[typeName] = modelName;
            this.modelNamesToTypeNames[modelName] = typeName;
        }
    }
    docToResource(doc, fields) {
        return doc_to_resource_1.default(this.models, this.modelNamesToTypeNames, doc, fields);
    }
    docsToResourceData(docs, isPlural, fields) {
        return this.constructor.docsToResourceData(this.models, this.modelNamesToTypeNames, docs, isPlural, fields);
    }
    getTypePath(model) {
        return subtyping_1.getTypePath(model, this.modelNamesToTypeNames);
    }
    find(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const { type, populates: includePaths, select: fields, sort: sorts, offset, limit, isSingular: singular } = query;
            const mode = singular ? "findOne" : "find";
            const filters = query.getFilters();
            const mongofiedFilters = util.toMongoCriteria(filters);
            const model = this.getModel(type);
            this.constructor.assertIdsValid(filters, singular);
            const isPaginating = mode !== "findOne" &&
                (typeof offset !== "undefined" || typeof limit !== "undefined");
            let primaryDocumentsPromise, includedResourcesPromise;
            const queryBuilder = mode === "findOne"
                ? model[mode](mongofiedFilters)
                : model[mode](mongofiedFilters);
            const collectionSizePromise = isPaginating
                ? model.count(mongofiedFilters).exec()
                : Promise.resolve(null);
            if (Array.isArray(sorts)) {
                const geoDistanceSort = sorts.find((it) => {
                    const exp = it.expression;
                    return exp && exp.operator === 'geoDistance';
                });
                if (geoDistanceSort) {
                    if (sorts.length !== 1) {
                        throw Errors.invalidQueryParamValue({
                            detail: `Cannot combine geoDistance sorts with other sorts.`,
                            source: { parameter: "sort" }
                        });
                    }
                    queryBuilder.near(geoDistanceSort.expression.args[0].value, {
                        center: {
                            type: "Point", coordinates: geoDistanceSort.expression.args[1]
                        },
                        maxDistance: 4503599627370496,
                        spherical: true
                    });
                }
                else {
                    queryBuilder.sort(sorts.map(it => {
                        if (!("field" in it)) {
                            throw new Error("Got unsupported expression sort field; shouldn't happen.");
                        }
                        return (it.direction === 'DESC' ? '-' : '') + it.field;
                    }).join(" "));
                }
            }
            if (offset) {
                queryBuilder.skip(offset);
            }
            if (limit) {
                queryBuilder.limit(limit);
            }
            if (includePaths && includePaths.length > 0) {
                const populatedPaths = [];
                const refPaths = schema_1.getReferencePaths(model);
                includePaths.map((it) => it.split(".")).forEach((pathParts) => {
                    if (!refPaths.includes(pathParts[0])) {
                        throw Errors.invalidIncludePath({
                            detail: `Resources of type "${type}" don't have a(n) "${pathParts[0]}" relationship.`
                        });
                    }
                    if (pathParts.length > 1) {
                        throw Errors.unsupportedIncludePath({
                            detail: `Multi-level include paths like ${pathParts.join('.')} aren't yet supported.`
                        });
                    }
                    populatedPaths.push(pathParts[0]);
                    queryBuilder.populate(pathParts[0]);
                });
                let includedResources = [];
                primaryDocumentsPromise = Promise.resolve(queryBuilder.exec()).then((docOrDocs) => {
                    includedResources =
                        objectValueEntries_1.values(Data_1.default.fromJSON(docOrDocs)
                            .flatMap((doc) => {
                            return Data_1.default.of(populatedPaths).flatMap((path) => {
                                return typeof doc[path] === 'undefined'
                                    ? Data_1.default.empty
                                    : Data_1.default.fromJSON(doc[path]).map(docAtPath => {
                                        return this.docToResource(docAtPath, fields);
                                    });
                            });
                        })
                            .values
                            .reduce((acc, resource) => {
                            acc[`${resource.type}/${resource.id}`] = resource;
                            return acc;
                        }, {}));
                    return docOrDocs;
                });
                includedResourcesPromise =
                    primaryDocumentsPromise.then(() => includedResources);
            }
            else {
                primaryDocumentsPromise = Promise.resolve(queryBuilder.exec());
                includedResourcesPromise = Promise.resolve(undefined);
            }
            return Promise.all([
                primaryDocumentsPromise.then((it) => {
                    return this.docsToResourceData(it, mode === 'find', fields);
                }),
                includedResourcesPromise,
                collectionSizePromise
            ])
                .catch(util.errorHandler);
        });
    }
    create(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const { records: resourceData } = query;
            const getSmallestSubType = (it) => it.typePath[0];
            const setIdWithGenerator = typeof this.idGenerator === "function" &&
                ((doc) => { doc._id = this.idGenerator(doc); });
            const resourcesByParentType = misc_1.partition('type', resourceData);
            const creationPromises = Object.keys(resourcesByParentType).map(type => {
                const model = this.getModel(type);
                const discriminatorKey = schema_1.getDiscriminatorKey(model);
                const resources = resourcesByParentType[type];
                const docObjects = resources.map((resource) => {
                    const finalModel = this.getModel(getSmallestSubType(resource));
                    const forbiddenKeys = schema_1.getMetaKeys(finalModel);
                    if (forbiddenKeys.some(k => k in resource.attrs || k in resource.relationships)) {
                        throw Errors.illegalFieldName();
                    }
                    return util.resourceToDocObject(resource, (typePath) => {
                        if (typePath.length === 1) {
                            return {};
                        }
                        const smallestSubType = getSmallestSubType(resource);
                        if (!discriminatorKey || !this.getModel(smallestSubType)) {
                            throw new Error("Unexpected model name. Should've been caught earlier.");
                        }
                        return { [discriminatorKey]: this.typeNamesToModelNames[smallestSubType] };
                    });
                });
                if (setIdWithGenerator) {
                    docObjects.forEach(setIdWithGenerator);
                }
                return model.create(docObjects);
            });
            return Promise.all(creationPromises).then((docArrays) => {
                const makeCollection = !resourceData.isSingular;
                const finalDocs = docArrays.reduce((a, b) => a.concat(b), []);
                return this.docsToResourceData(finalDocs, makeCollection);
            }).catch(util.errorHandler);
        });
    }
    update(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const { type: parentType, patch } = query;
            const parentModel = this.getModel(parentType);
            const prefetchedDocs = patch.map(it => it.adapterExtra).values.filter(it => !!it);
            const getOIdAsString = R.pipe(R.prop('_id'), String);
            const docIdsToFetch = [...misc_1.setDifference(patch.map(R.prop('id')).values, prefetchedDocs.map(getOIdAsString))];
            const remainingDocsQuery = parentModel.find({ _id: { $in: docIdsToFetch } }).lean();
            const docsToUpdate = docIdsToFetch.length === 0
                ? prefetchedDocs
                : [...prefetchedDocs, ...yield remainingDocsQuery.exec()];
            const docsToUpdateById = docsToUpdate.reduce(misc_1.reduceToObject(getOIdAsString), {});
            const updateOpts = {
                new: true,
                runValidators: false,
                upsert: false,
                strict: true
            };
            const singleDocUpdateQueries = yield patch.mapAsync((resourceUpdate) => __awaiter(this, void 0, void 0, function* () {
                const Model = this.getModel(resourceUpdate.typePath[0]);
                const versionKey = schema_1.getVersionKey(Model);
                if (!Model) {
                    throw new Error("Unknown model name.");
                }
                const existingDoc = docsToUpdateById[resourceUpdate.id];
                const changeSet = util.resourceToDocObject(resourceUpdate);
                if (!existingDoc) {
                    throw Errors.genericNotFound({
                        detail: `First missing resource was (${resourceUpdate.type}, ${resourceUpdate.id}).`
                    });
                }
                const forbiddenKeys = schema_1.getMetaKeys(Model);
                if (forbiddenKeys.some(k => k in changeSet)) {
                    throw Errors.illegalFieldName();
                }
                const updatedDoc = Model.hydrate(existingDoc).set(changeSet);
                try {
                    yield updatedDoc.validate();
                }
                catch (e) {
                    util.errorHandler(e);
                }
                const modifiedPaths = updatedDoc.modifiedPaths();
                const updatedDocObject = updatedDoc.toObject();
                const finalUpdate = modifiedPaths.reduce((acc, key) => {
                    acc[key] = updatedDocObject[key];
                    return acc;
                }, {
                    "$inc": { [versionKey]: 1 }
                });
                const criteria = {
                    _id: resourceUpdate.id,
                    [versionKey]: existingDoc[versionKey]
                };
                return [parentModel.findOneAndUpdate(criteria, finalUpdate, updateOpts)];
            }));
            return singleDocUpdateQueries.flatMapAsync(([docUpdateQuery]) => __awaiter(this, void 0, void 0, function* () {
                const doc = yield docUpdateQuery.exec().catch(util.errorHandler);
                if (!doc) {
                    throw Errors.occFail();
                }
                return this.docsToResourceData(doc, false);
            }));
        });
    }
    delete(query) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!query.isSimpleIdQuery()) {
                throw new Error("Unsupported delete query");
            }
            const { type, isSingular: singular } = query;
            const mode = singular ? 'findOne' : 'find';
            const filters = query.getFilters();
            const mongofiedFilters = util.toMongoCriteria(filters);
            this.constructor.assertIdsValid(filters, singular);
            const QueryTypeModel = this.getModel(type);
            const baseModelName = QueryTypeModel.baseModelName || QueryTypeModel.modelName;
            const BaseModel = this.getModel(this.modelNamesToTypeNames[baseModelName]);
            const queryBuilder = mode === 'findOne'
                ? BaseModel[mode](mongofiedFilters)
                : BaseModel[mode](mongofiedFilters);
            const docsToDelete = yield queryBuilder.exec().then((docOrDocsOrNull) => {
                return Data_1.default.fromJSON(docOrDocsOrNull);
            }, util.errorHandler);
            const hasTypePathThrough = (throughType, doc) => {
                return this.getTypePath(doc.constructor).includes(throughType);
            };
            if (!docsToDelete.every(R.partial(hasTypePathThrough, [type]))) {
                throw Errors.invalidResourceType();
            }
            if (singular && docsToDelete.size === 0) {
                throw Errors.genericNotFound();
            }
            docsToDelete.forEach(it => { it.remove(); });
            return docsToDelete.map((it) => this.docToResource(it));
        });
    }
    addToRelationship(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const { type, id, relationshipName, linkage: newLinkage } = query;
            const model = this.getModel(type);
            this.assertRelationshipLinkageTypeValid(model, relationshipName, newLinkage);
            const options = { runValidators: true, context: "query" };
            const update = {
                $addToSet: {
                    [relationshipName]: { $each: newLinkage.map(it => it.id) }
                },
                $inc: { [schema_1.getVersionKey(model)]: 1 }
            };
            return model.findOneAndUpdate({ "_id": id }, update, options).exec()
                .catch(util.errorHandler);
        });
    }
    removeFromRelationship(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const { type, id, relationshipName, linkage: linkageToRemove } = query;
            const model = this.getModel(type);
            this.assertRelationshipLinkageTypeValid(model, relationshipName, linkageToRemove);
            const update = {
                $pullAll: {
                    [relationshipName]: linkageToRemove.map(it => it.id)
                },
                $inc: { [schema_1.getVersionKey(model)]: 1 }
            };
            const options = { runValidators: true, context: "query" };
            return model.findOneAndUpdate({ "_id": id }, update, options).exec()
                .catch(util.errorHandler);
        });
    }
    getTypePaths(items) {
        return __awaiter(this, void 0, void 0, function* () {
            const itemsByType = misc_1.partition("type", items);
            const types = Object.keys(itemsByType);
            const res = {};
            for (const type of types) {
                const theseItems = itemsByType[type];
                const BaseModel = this.getModel(type);
                const discriminatorKey = schema_1.getDiscriminatorKey(BaseModel);
                const modelForLeanDoc = (it) => (discriminatorKey && it[discriminatorKey])
                    ? this.getModel(this.modelNamesToTypeNames[it[discriminatorKey]])
                    : BaseModel;
                if (!BaseModel.discriminators) {
                    res[type] = theseItems.reduce((acc, item) => {
                        acc[item.id] = { typePath: this.getTypePath(BaseModel) };
                        return acc;
                    }, {});
                }
                else {
                    const docsPromise = BaseModel.find({ _id: { $in: theseItems.map(it => it.id) } }).lean().exec();
                    res[type] = docsPromise.then(docs => {
                        return docs.reduce((acc, doc) => {
                            acc[String(doc._id)] = {
                                typePath: this.getTypePath(modelForLeanDoc(doc)),
                                extra: doc
                            };
                            return acc;
                        }, {});
                    });
                }
            }
            const values = yield Promise.all(types.map(type => res[type]));
            return types.reduce((acc, type, i) => {
                acc[type] = values[i];
                return acc;
            }, {});
        });
    }
    getModel(typeName) {
        const modelName = this.typeNamesToModelNames[typeName];
        if (!modelName || !this.models[modelName]) {
            throw new Error(`No model for type "${typeName}" is registered with the MongooseAdapter.`);
        }
        return this.models[modelName];
    }
    getRelationshipNames(typeName) {
        const model = this.getModel(typeName);
        return schema_1.getReferencePaths(model);
    }
    doQuery(query) {
        const method = ((query instanceof CreateQuery_1.default && this.create) ||
            (query instanceof FindQuery_1.default && this.find) ||
            (query instanceof DeleteQuery_1.default && this.delete) ||
            (query instanceof UpdateQuery_1.default && this.update) ||
            (query instanceof AddToRelationshipQuery_1.default && this.addToRelationship) ||
            (query instanceof RemoveFromRelationshipQuery_1.default && this.removeFromRelationship));
        if (!method) {
            throw new Error("Unexpected query type.");
        }
        return method.call(this, query);
    }
    assertRelationshipLinkageTypeValid(ownerModel, relationshipName, linkage) {
        const rootTypeNameForRefModel = (() => {
            try {
                const refModelName = schema_1.getReferencedModelName(ownerModel, relationshipName);
                const refModelType = this.modelNamesToTypeNames[refModelName];
                const refModel = this.getModel(refModelType);
                return this.getTypePath(refModel).pop();
            }
            catch (e) {
                throw new Error(`Missing/invalid model name for relationship ${relationshipName}.`);
            }
        })();
        if (!linkage.every(it => it.type === rootTypeNameForRefModel)) {
            throw Errors.invalidLinkageType({
                detail: `All linkage must have type: ${rootTypeNameForRefModel}.`
            });
        }
    }
    static docsToResourceData(models, modelNamesToTypeNames, docs, isPlural, fields) {
        if (!docs || (!isPlural && Array.isArray(docs) && docs.length === 0)) {
            throw Errors.genericNotFound();
        }
        const docsArray = !Array.isArray(docs) ? [docs] : docs;
        const resources = docsArray.map((it) => doc_to_resource_1.default(models, modelNamesToTypeNames, it, fields));
        return isPlural ? Data_1.default.of(resources) : Data_1.default.pure(resources[0]);
    }
    static getStandardizedSchema(model, pluralizer = pluralize.plural.bind(pluralize)) {
        const versionKey = schema_1.getVersionKey(model);
        const discriminatorKey = schema_1.getDiscriminatorKey(model);
        const virtuals = model.schema.virtuals;
        const schemaFields = [];
        const getFieldType = (path, schemaType) => {
            if (path === "_id") {
                return new FieldType_1.default("Id", false);
            }
            const typeOptions = schemaType.options.type;
            const holdsArray = Array.isArray(typeOptions);
            const baseType = holdsArray ? typeOptions[0].ref : typeOptions.name;
            const refModelName = schema_1.getReferencedModelName(model, path);
            return !refModelName ?
                new FieldType_1.default(baseType, holdsArray) :
                new RelationshipType_1.default(holdsArray, refModelName, naming_conventions_1.getTypeName(refModelName, pluralizer));
        };
        model.schema.eachPath((name, type) => {
            if ([versionKey, discriminatorKey].includes(name)) {
                return;
            }
            const schemaType = type;
            const fieldType = getFieldType(name, schemaType);
            const publicName = name === "_id" ? "id" : name;
            const likelyAutoGenerated = publicName === "id" ||
                (fieldType.baseType === "Date" &&
                    /created|updated|modified/.test(publicName) &&
                    typeof schemaType.options.default === "function");
            let defaultVal;
            if (likelyAutoGenerated) {
                defaultVal = "__AUTO__";
            }
            else if (schemaType.options.default && typeof schemaType.options.default !== "function") {
                defaultVal = schemaType.options.default;
            }
            const baseTypeOptions = Array.isArray(schemaType.options.type)
                ? schemaType.options.type[0]
                : schemaType.options;
            const validationRules = {
                required: !!schemaType.options.required,
                oneOf: baseTypeOptions.enum
                    ? schemaType.enumValues ||
                        (schemaType.caster && schemaType.caster.enumValues)
                    : undefined,
                max: schemaType.options.max || undefined
            };
            schemaType.validators.forEach((validatorObj) => {
                Object.assign(validationRules, validatorObj.validator.JSONAPIDocumentation);
            });
            schemaFields.push(new Field_1.default(publicName, fieldType, validationRules, this.toFriendlyName(publicName), defaultVal));
        });
        for (const virtual in virtuals) {
            if (virtual === "id") {
                continue;
            }
            schemaFields.push(new Field_1.default(virtual, undefined, undefined, this.toFriendlyName(virtual)));
        }
        return schemaFields;
    }
    static toFriendlyName(pathOrModelName) {
        const ucFirst = (v) => v.charAt(0).toUpperCase() + v.slice(1);
        const pascalCasedString = pathOrModelName.split(".").map(ucFirst).join("");
        let matches;
        const words = [];
        const wordsRe = /[A-Z]([A-Z]*(?![^A-Z])|[^A-Z]*)/g;
        while ((matches = wordsRe.exec(pascalCasedString)) !== null) {
            words.push(matches[0]);
        }
        return words.join(" ");
    }
    static assertIdsValid(filters, isSingular) {
        const idsArray = filters.args.reduce((acc, filter) => {
            return parse_query_params_1.isId(filter.args[0]) && filter.args[0].value === 'id'
                ? acc.concat(filter.args[1])
                : acc;
        }, []);
        if (!idsArray.every(this.idIsValid)) {
            throw isSingular
                ? Errors.genericNotFound({ detail: "Invalid ID." })
                : Errors.invalidId();
        }
    }
    static idIsValid(id) {
        return typeof id === "string" && /^[0-9a-fA-F]{24}$/.test(id);
    }
}
MongooseAdapter.supportedOperators = {
    "and": {},
    "or": {},
    'eq': {},
    'neq': {},
    'ne': {},
    'in': {},
    'nin': {},
    'lt': {},
    'gt': {},
    'lte': {},
    'gte': {},
    'geoDistance': {
        isBinary: true,
        legalIn: ["sort"],
        finalizeArgs(operators, operator, args) {
            if (!parse_query_params_1.isId(args[0])) {
                throw new SyntaxError(`"geoDistance" operator expects field reference as first argument.`);
            }
            const isPoint = R.allPass([
                Array.isArray,
                R.pipe(R.length, R.equals(2)),
                R.all(it => Number(it) === it)
            ]);
            if (!isPoint(args[1])) {
                throw new SyntaxError(`"geoDistance" operator expects [lng,lat] as second argument.`);
            }
            return args;
        }
    }
};
exports.default = MongooseAdapter;
