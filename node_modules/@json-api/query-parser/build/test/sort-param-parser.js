"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const { expect } = require("chai");
const utils_1 = require("./utils");
const sort_param_parser_1 = require("../src/sort-param-parser");
const noValidationFinalizeArgs = function (a, b, args) {
    return args;
};
const eqOperator = {
    "eq": { isBinary: true, finalizeArgs: noValidationFinalizeArgs }
};
const andOrOperators = {
    "and": { isBinary: false, finalizeArgs: noValidationFinalizeArgs },
    "or": { isBinary: false, finalizeArgs: noValidationFinalizeArgs }
};
const gteExtendedOperator = {
    "gte": {
        isBinary: false,
        finalizeArgs(a, b, args) {
            return ["custom args"];
        }
    }
};
describe("Sort param parsing", () => {
    it("should allow a mix of field expressions and simple fields", () => {
        expect(sort_param_parser_1.default(eqOperator, "test,(a,4)")).to.deep.equal([
            { direction: "ASC", field: "test" },
            { direction: "ASC", expression: utils_1.FieldExpression('eq', [utils_1.Identifier("a"), 4]) }
        ]);
        expect(sort_param_parser_1.default(eqOperator, "-(a,4)")).to.deep.equal([
            { direction: "DESC", expression: utils_1.FieldExpression('eq', [utils_1.Identifier("a"), 4]) }
        ]);
        expect(sort_param_parser_1.default(eqOperator, "test")).to.deep.equal([
            { direction: "ASC", field: "test" }
        ]);
    });
    it("should error if a field expression is invalid", () => {
        expect(() => sort_param_parser_1.default(eqOperator, "test,(now)")).to.throw(/must have a valid operator/);
        expect(() => sort_param_parser_1.default(eqOperator, "(now)")).to.throw(/must have a valid operator/);
    });
    it("should (recursively) process the field expressions, calling finalizeArgs", () => {
        const sutWithOps = sort_param_parser_1.default.bind(null, Object.assign({}, eqOperator, gteExtendedOperator, andOrOperators));
        expect(sutWithOps("-hello,(and,(or,(and,(it,3)),(gte,1000,fieldName,230)),(field,eq,2))"))
            .to.deep.equal([{
                direction: "DESC",
                field: "hello"
            }, {
                direction: "ASC",
                expression: utils_1.FieldExpression("and", [
                    utils_1.FieldExpression("or", [
                        utils_1.FieldExpression("and", [
                            utils_1.FieldExpression("eq", [utils_1.Identifier("it"), 3])
                        ]),
                        utils_1.FieldExpression("gte", ["custom args"])
                    ]),
                    utils_1.FieldExpression("eq", [{ type: "Identifier", value: "field" }, 2])
                ])
            }]);
    });
    it("should parse direction", () => {
        expect(sort_param_parser_1.default(eqOperator, "test,-test,(1,1),-(1,1)")).to.deep.equal([
            { direction: "ASC", field: "test" },
            { direction: "DESC", field: "test" },
            { direction: "ASC", expression: utils_1.FieldExpression("eq", [1, 1]) },
            { direction: "DESC", expression: utils_1.FieldExpression("eq", [1, 1]) },
        ]);
    });
});
