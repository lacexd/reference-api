"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const { expect } = require("chai");
const helpers_1 = require("../src/helpers");
const utils_1 = require("./utils");
const filter_param_parser_1 = require("../src/filter-param-parser");
const noValidationFinalizeArgs = function (a, b, args) {
    return args;
};
const eqOperator = {
    "eq": { isBinary: true, finalizeArgs: noValidationFinalizeArgs }
};
const andOrOperators = {
    "and": { isBinary: false, finalizeArgs: noValidationFinalizeArgs },
    "or": { isBinary: false, finalizeArgs: noValidationFinalizeArgs }
};
const gteOperator = {
    "gte": { isBinary: true, finalizeArgs: noValidationFinalizeArgs }
};
const nowOperator = {
    "now": { isBinary: false, finalizeArgs: noValidationFinalizeArgs }
};
const andOrProperOperators = {
    "and-list": {
        isBinary: false,
        finalizeArgs(a, b, c) {
            if (!c.every(it => it && it.type === "FieldExpression")) {
                throw new Error("Arguments must be field expressions.");
            }
            return c;
        }
    },
    "or-list": {
        isBinary: false,
        finalizeArgs(a, b, c) {
            if (!c.every(it => it && it.type === "FieldExpression")) {
                throw new Error("Arguments must be field expressions.");
            }
            return c;
        }
    }
};
const nowProperOperator = {
    "now": {
        isBinary: false,
        finalizeArgs(a, b, args) {
            if (args.length) {
                throw new Error("`now` operator cannot take any arguments.");
            }
            return args;
        }
    }
};
const withFieldOperators = {
    "eq": {
        isBinary: true,
        finalizeArgs(a, b, args) {
            if (!helpers_1.isId(args[0])) {
                throw new Error("field reference required as first argument.");
            }
            return args;
        }
    },
    "lte": {
        isBinary: true,
        finalizeArgs(a, b, args) {
            if (!helpers_1.isId(args[0])) {
                throw new Error("field reference required as first argument.");
            }
            return args;
        }
    }
};
const gteExtendedOperator = {
    "gte": {
        isBinary: false,
        finalizeArgs(a, b, args) {
            return ["custom args"];
        }
    }
};
describe("Filter param parsing", () => {
    describe("Empty lists", () => {
        it("Should reject them as invalid filter constraints", () => {
            expect(() => filter_param_parser_1.default(eqOperator, "()")).to.throw(/Expected field expression/);
        });
    });
    describe("One items lists", () => {
        it("should reject if the item isn't a known operator", () => {
            expect(() => filter_param_parser_1.default(eqOperator, "(now)")).to.throw(/must have a valid operator/);
        });
        it("should reject if the item is a binary operator", () => {
            expect(() => filter_param_parser_1.default(eqOperator, "(eq)")).to.throw(/"eq" .+ binary .+ infixed/);
        });
        it("should treat as an expression with an empty arg list if the operator is known + n-ary", () => {
            expect(filter_param_parser_1.default(nowOperator, "(now)")).to.deep.equal([
                utils_1.FieldExpression("now", [])
            ]);
        });
    });
    describe("Two item lists", () => {
        it("should recognize valid n-ary operators", () => {
            expect(filter_param_parser_1.default(nowOperator, "(now,1)")).to.deep.equal([
                utils_1.FieldExpression("now", [1])
            ]);
        });
        it("should infer `eq` if no known n-ary operator is present and eq is known", () => {
            expect(filter_param_parser_1.default(eqOperator, "(fieldName,1)")).to.deep.equal([
                utils_1.FieldExpression("eq", [utils_1.Identifier("fieldName"), 1])
            ]);
        });
        it("should not try to recognize a binary operator", () => {
            const missingItemError = /binary .+ must have exactly three items/;
            expect(() => filter_param_parser_1.default(gteOperator, "(gte,1)")).to.throw(/"gte" .+ binary .+ infixed/);
            expect(() => filter_param_parser_1.default(gteOperator, "(1,gte)")).to.throw(missingItemError);
            expect(() => filter_param_parser_1.default(gteOperator, "(fieldName,gte)")).to.throw(missingItemError);
        });
        it("should error if no known operator is present and eq isn't known", () => {
            expect(() => filter_param_parser_1.default(nowOperator, "(2,1)")).to.throw();
        });
    });
    describe("three item lists", () => {
        it("should appropriately recognize infixed binary operators in valid lists", () => {
            expect(filter_param_parser_1.default(eqOperator, "(fieldName,eq,1)")).to.deep.equal([
                utils_1.FieldExpression("eq", [{ type: "Identifier", value: "fieldName" }, 1])
            ]);
            expect(filter_param_parser_1.default(gteOperator, "(fieldName,gte,1)")).to.deep.equal([
                utils_1.FieldExpression("gte", [{ type: "Identifier", value: "fieldName" }, 1])
            ]);
        });
        it("should reject leading binary operators, assuming no infixed op", () => {
            expect(() => filter_param_parser_1.default(gteOperator, "(gte,fieldName,1)")).to.throw();
            expect(filter_param_parser_1.default(gteOperator, "(gte,gte,1)")).to.deep.equal([
                utils_1.FieldExpression("gte", [{ type: "Identifier", value: "gte" }, 1])
            ]);
        });
        it("should recognize leading n-ary operators", () => {
            expect(filter_param_parser_1.default(nowOperator, "(now,fieldName,[])")).to.deep.equal([
                utils_1.FieldExpression("now", [utils_1.Identifier("fieldName"), []])
            ]);
        });
        it("should prefer a known infixed binary op over a known leadingnary op", () => {
            expect(filter_param_parser_1.default(Object.assign({}, nowOperator, gteOperator), "(now,gte,[2])"))
                .to.deep.equal([
                utils_1.FieldExpression("gte", [utils_1.Identifier("now"), [2]])
            ]);
        });
        it("should error if first arg is not a known operator", () => {
            expect(() => filter_param_parser_1.default(eqOperator, "(now,fieldName,[])")).to.throw();
        });
    });
    describe("4+-item lists", () => {
        it("should reject if the first item isn't a known nary operator", () => {
            expect(() => filter_param_parser_1.default(eqOperator, "(now,test,3,14)"))
                .to.throw(/must have a valid operator/);
            expect(() => filter_param_parser_1.default(eqOperator, "(fieldName,eq,3,14)"))
                .to.throw(/"eq" .+ binary .+ exactly three items/);
            expect(() => filter_param_parser_1.default(eqOperator, "(eq,3,14,3)"))
                .to.throw(/"eq" .+ binary .+ infixed/);
        });
        it("should wrap up all args into an array", () => {
            expect(filter_param_parser_1.default(nowOperator, "(now,233,fieldName,(now),[true])")).to.deep.equal([
                utils_1.FieldExpression("now", [233, utils_1.Identifier("fieldName"), utils_1.FieldExpression("now", []), [true]])
            ]);
        });
    });
    describe("multiple constraints", () => {
        it("should support them, one listed directly after the other", () => {
            expect(filter_param_parser_1.default(withFieldOperators, "(a,lte,1)(a,4)")).to.deep.equal([
                utils_1.FieldExpression("lte", [utils_1.Identifier("a"), 1]),
                utils_1.FieldExpression("eq", [utils_1.Identifier("a"), 4])
            ]);
        });
    });
    describe("finalizeArgs", () => {
        it("should call it recursively", () => {
            expect(filter_param_parser_1.default(gteExtendedOperator, "(gte,1000,fieldName,230)")).to.deep.equal([
                utils_1.FieldExpression("gte", ["custom args"])
            ]);
            expect(filter_param_parser_1.default(Object.assign({}, andOrOperators, gteExtendedOperator), "(and,(gte,1000,fieldName,230))")).to.deep.equal([
                utils_1.FieldExpression("and", [utils_1.FieldExpression("gte", ["custom args"])])
            ]);
            expect(() => filter_param_parser_1.default(nowProperOperator, "(now,1)"))
                .to.throw(/`now` operator cannot take any arguments/);
            expect(filter_param_parser_1.default(nowProperOperator, "(now)")).to.deep.equal([
                utils_1.FieldExpression("now", [])
            ]);
            const missingFieldError = /field reference required/;
            expect(() => filter_param_parser_1.default(withFieldOperators, "(2,1)")).to.throw(missingFieldError);
            expect(() => filter_param_parser_1.default(withFieldOperators, "(2,eq,1)")).to.throw(missingFieldError);
            expect(() => filter_param_parser_1.default(withFieldOperators, "(2,lte,1)")).to.throw(missingFieldError);
            expect(() => filter_param_parser_1.default(withFieldOperators, "((a,eq,c),lte,1)")).to.throw(missingFieldError);
            expect(() => filter_param_parser_1.default(withFieldOperators, "(null,lte,1)")).to.throw(missingFieldError);
            expect(() => filter_param_parser_1.default(withFieldOperators, "([a,b],lte,1)")).to.throw(missingFieldError);
            expect(() => filter_param_parser_1.default(withFieldOperators, "(test,1)")).to.not.throw();
            expect(() => filter_param_parser_1.default(withFieldOperators, "(test,eq,1)")).to.not.throw();
            expect(() => filter_param_parser_1.default(withFieldOperators, "(test,lte,1)")).to.not.throw();
        });
    });
    describe("operators with raw field expressions as args", () => {
        it("should (recursively) process the field expressions, calling finalizeArgs", () => {
            const sutWithOps = filter_param_parser_1.default.bind(null, Object.assign({}, eqOperator, nowProperOperator, gteOperator, andOrOperators, andOrProperOperators));
            const invalidsToErrors = {
                "(or,(field,gte,2),(test,fieldName,3))": /must have a valid operator symbol/,
                "(and,(or,(test,x,1)))": /must have a valid operator symbol/,
                "(and-list,true)": /arguments must be field expressions/i,
                "(or-list,(field,eq,2),(date,gte,(now)),(and-list,test))": /arguments must be field expressions/i,
            };
            Object.keys(invalidsToErrors).forEach(k => {
                expect(() => sutWithOps(k)).to.throw(invalidsToErrors[k]);
            });
            expect(sutWithOps("(and,(field,eq,2),(date,gte,(now)),(test,4))"))
                .to.deep.equal([
                utils_1.FieldExpression("and", [
                    utils_1.FieldExpression("eq", [{ type: "Identifier", value: "field" }, 2]),
                    utils_1.FieldExpression("gte", [utils_1.Identifier("date"), utils_1.FieldExpression("now", [])]),
                    utils_1.FieldExpression("eq", [{ type: "Identifier", value: "test" }, 4])
                ])
            ]);
            expect(sutWithOps("(and,true)")).to.deep.equal([
                utils_1.FieldExpression("and", [true])
            ]);
            expect(filter_param_parser_1.default(withFieldOperators, "(test,lte,(a,eq,c))")).to.deep.equal([
                utils_1.FieldExpression("lte", [
                    utils_1.Identifier("test"),
                    utils_1.FieldExpression("eq", [utils_1.Identifier("a"), utils_1.Identifier("c")])
                ])
            ]);
            expect(sutWithOps("(and,(or,(and,(it,3)),(test,gte,null)))"))
                .to.deep.equal([
                utils_1.FieldExpression("and", [
                    utils_1.FieldExpression("or", [
                        utils_1.FieldExpression("and", [
                            utils_1.FieldExpression("eq", [utils_1.Identifier("it"), 3])
                        ]),
                        utils_1.FieldExpression("gte", [utils_1.Identifier("test"), null])
                    ])
                ])
            ]);
        });
    });
});
