"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const R = require("ramda");
exports.isId = (it) => it && it.type === "Identifier";
exports.isKnownOperator = R.curry((operators, node) => {
    return exports.isId(node) && Boolean(operators[node.value]);
});
exports.isBinaryOperator = R.curry((operators, node) => {
    return exports.isKnownOperator(operators, node) && operators[node.value].isBinary;
});
exports.isNaryOperator = R.curry((operators, node) => {
    return exports.isKnownOperator(operators, node) && !(operators[node.value].isBinary);
});
exports.toFieldExpression = R.curry((operators, it) => {
    if (!(it && it.type === "RawFieldExpression")) {
        throw new SyntaxError("Expected a parenthesized list.");
    }
    const list = it.items;
    if (list.length === 3 && exports.isBinaryOperator(operators, list[1])) {
        return {
            type: "FieldExpression",
            operator: list[1].value,
            args: [list[0], list[2]]
        };
    }
    else if (exports.isNaryOperator(operators, list[0])) {
        return {
            type: "FieldExpression",
            operator: list[0].value,
            args: list.slice(1)
        };
    }
    else if (list.length === 2 && operators["eq"]) {
        return {
            type: "FieldExpression",
            operator: "eq",
            args: list
        };
    }
    if (exports.isBinaryOperator(operators, list[1])) {
        throw new SyntaxError(`"${list[1].value}" is a binary operator, so the field expression ` +
            "must have exactly three items.");
    }
    if (exports.isBinaryOperator(operators, list[0])) {
        throw new SyntaxError(`"${list[0].value}" is a binary operator, so it must be infixed as ` +
            "the second item in your field expression.");
    }
    throw new SyntaxError("Field expressions must have a valid operator symbol as their first " +
        "item (for non-binary operators) or second item (for binary operators), " +
        "or must be a two-item list without any operators (in which case the " +
        "`eq` operator is inferred, if it's supported).");
});
function finalizeFieldExpression(operators, it) {
    const finalizedExp = exports.toFieldExpression(operators, it);
    const finalArgs = operators[finalizedExp.operator].finalizeArgs(operators, finalizedExp.operator, finalizedExp.args.map((arg) => {
        if (arg && arg.type === 'RawFieldExpression') {
            return finalizeFieldExpression(operators, arg);
        }
        return arg;
    }));
    return Object.assign({}, finalizedExp, { args: finalArgs });
}
exports.finalizeFieldExpression = finalizeFieldExpression;
